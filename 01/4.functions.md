# ⚙️ 3.5-kun: Functions — “Go’da funksiya oddiy, lekin kuchli”

### 1. Oddiy funksiya

Go’da funksiya `func` kalit so‘zi bilan yoziladi.

```go
package main

import "fmt"

func sayHello() {
    fmt.Println("Salom, Golang!")
}

func main() {
    sayHello()
}
```

Hech qanday sinf (class) kerak emas — shunchaki funksiya.

---

### 2. Parametrli funksiya

```go
func greet(name string) {
    fmt.Println("Salom,", name)
}

func main() {
    greet("Tohir")
}
```

Bu joyda **har bir parametr turi aniq ko‘rsatilishi kerak**.
Python’da esa funksiya:

```python
def greet(name):
    print("Salom,", name)
```

deb yoziladi — Go’da bu aniqroq, lekin qattiqroq qoidaga ega.

---

### 3. Bir nechta argument va natija qaytarish

Go’da funksiya **bir nechta qiymat** qaytara oladi.
Bu Python’dagi “tuple return”ga o‘xshash, lekin aniqroq:

```go
func addAndMultiply(a, b int) (int, int) {
    sum := a + b
    mul := a * b
    return sum, mul
}

func main() {
    s, m := addAndMultiply(3, 4)
    fmt.Println("Yig‘indi:", s, "Ko‘paytma:", m)
}
```

chiqadi:

```
Yig‘indi: 7 Ko‘paytma: 12
```

---

### 4. Nomlangan qaytish qiymatlari (named return)

Agar qiymatlarni nom bilan e’lon qilsangiz, `return` ni bo‘sh qoldirishingiz mumkin.

```go
func squareAndCube(x int) (kvadrat, kub int) {
    kvadrat = x * x
    kub = x * x * x
    return // bu yerda return kvadrat, kub ni avtomatik qaytaradi
}
```

---

### 5. Variadic function (cheksiz argumentlar)

Go’da siz `*args` ga o‘xshash funksiya yaratishingiz mumkin.

```go
func sum(nums ...int) int {
    total := 0
    for _, v := range nums {
        total += v
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3, 4, 5))
}
```

Python’da bu `def sum(*nums):` ga teng.

---

### 6. Error handling (Go’ning eng muhim falsafasi)

Go’da **try/except** yo‘q!
Buning o‘rniga har bir funksiya **natija + error** qaytaradi.

```go
import (
    "fmt"
    "errors"
)

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("0 ga bo‘lish mumkin emas")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Xato:", err)
        return
    }
    fmt.Println("Natija:", result)
}
```

Natija:

```
Xato: 0 ga bo‘lish mumkin emas
```

Python’da bu:

```python
try:
    ...
except ZeroDivisionError:
    ...
```

Go’da esa bu mantiq aniq va **nazorat dasturchining qo‘lida**.

---

### 🧠 Muhim falsafa:

Go’da xatolar “istisno emas”, balki **oddiy qiymat**.
Bu “Go simplicity rule” deb ataladi.
Ya’ni: “Agar xato bo‘lsa, uni boshqar — yashirma.”

---

### 🧪 Amaliy mashq:

Funksiya yozing:

```go
func divideList(nums []float64, divisor float64) ([]float64, error)
```

U `nums`dagi har bir sonni `divisor`ga bo‘lsin.
Agar `divisor == 0` bo‘lsa — `error` qaytarsin.
Agar hammasi joyida bo‘lsa — bo‘lingan massivni qaytarsin.

Misol:

```
nums := []float64{10, 20, 30}
result, err := divideList(nums, 2)
```

Natija: `[5, 10, 15]`

---

### 🎯 Yakun:

Bugun siz:

* Go’da funksiyalarni yaratish,
* Bir nechta qiymat qaytarish,
* Variadic argumentlar bilan ishlash,
* va Go’ning **error handling falsafasi**ni o‘rgandingiz.

Bu darsdan so‘ng sizning qo‘lingizda **mustaqil kod bloklarini yozish** qudrati paydo bo‘ldi — endi siz `package`’lar, `modules`, va **professional loyihani qanday strukturalash**ni o‘rganishga tayyorsiz.

---