# âš™ï¸ 3.5-kun: Functions â€” â€œGoâ€™da funksiya oddiy, lekin kuchliâ€

### 1. Oddiy funksiya

Goâ€™da funksiya `func` kalit soâ€˜zi bilan yoziladi.

```go
package main

import "fmt"

func sayHello() {
    fmt.Println("Salom, Golang!")
}

func main() {
    sayHello()
}
```

Hech qanday sinf (class) kerak emas â€” shunchaki funksiya.

---

### 2. Parametrli funksiya

```go
func greet(name string) {
    fmt.Println("Salom,", name)
}

func main() {
    greet("Tohir")
}
```

Bu joyda **har bir parametr turi aniq koâ€˜rsatilishi kerak**.
Pythonâ€™da esa funksiya:

```python
def greet(name):
    print("Salom,", name)
```

deb yoziladi â€” Goâ€™da bu aniqroq, lekin qattiqroq qoidaga ega.

---

### 3. Bir nechta argument va natija qaytarish

Goâ€™da funksiya **bir nechta qiymat** qaytara oladi.
Bu Pythonâ€™dagi â€œtuple returnâ€ga oâ€˜xshash, lekin aniqroq:

```go
func addAndMultiply(a, b int) (int, int) {
    sum := a + b
    mul := a * b
    return sum, mul
}

func main() {
    s, m := addAndMultiply(3, 4)
    fmt.Println("Yigâ€˜indi:", s, "Koâ€˜paytma:", m)
}
```

chiqadi:

```
Yigâ€˜indi: 7 Koâ€˜paytma: 12
```

---

### 4. Nomlangan qaytish qiymatlari (named return)

Agar qiymatlarni nom bilan eâ€™lon qilsangiz, `return` ni boâ€˜sh qoldirishingiz mumkin.

```go
func squareAndCube(x int) (kvadrat, kub int) {
    kvadrat = x * x
    kub = x * x * x
    return // bu yerda return kvadrat, kub ni avtomatik qaytaradi
}
```

---

### 5. Variadic function (cheksiz argumentlar)

Goâ€™da siz `*args` ga oâ€˜xshash funksiya yaratishingiz mumkin.

```go
func sum(nums ...int) int {
    total := 0
    for _, v := range nums {
        total += v
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3, 4, 5))
}
```

Pythonâ€™da bu `def sum(*nums):` ga teng.

---

### 6. Error handling (Goâ€™ning eng muhim falsafasi)

Goâ€™da **try/except** yoâ€˜q!
Buning oâ€˜rniga har bir funksiya **natija + error** qaytaradi.

```go
import (
    "fmt"
    "errors"
)

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("0 ga boâ€˜lish mumkin emas")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Xato:", err)
        return
    }
    fmt.Println("Natija:", result)
}
```

Natija:

```
Xato: 0 ga boâ€˜lish mumkin emas
```

Pythonâ€™da bu:

```python
try:
    ...
except ZeroDivisionError:
    ...
```

Goâ€™da esa bu mantiq aniq va **nazorat dasturchining qoâ€˜lida**.

---

### ğŸ§  Muhim falsafa:

Goâ€™da xatolar â€œistisno emasâ€, balki **oddiy qiymat**.
Bu â€œGo simplicity ruleâ€ deb ataladi.
Yaâ€™ni: â€œAgar xato boâ€˜lsa, uni boshqar â€” yashirma.â€

---

### ğŸ§ª Amaliy mashq:

Funksiya yozing:

```go
func divideList(nums []float64, divisor float64) ([]float64, error)
```

U `nums`dagi har bir sonni `divisor`ga boâ€˜lsin.
Agar `divisor == 0` boâ€˜lsa â€” `error` qaytarsin.
Agar hammasi joyida boâ€˜lsa â€” boâ€˜lingan massivni qaytarsin.

Misol:

```
nums := []float64{10, 20, 30}
result, err := divideList(nums, 2)
```

Natija: `[5, 10, 15]`

---

### ğŸ¯ Yakun:

Bugun siz:

* Goâ€™da funksiyalarni yaratish,
* Bir nechta qiymat qaytarish,
* Variadic argumentlar bilan ishlash,
* va Goâ€™ning **error handling falsafasi**ni oâ€˜rgandingiz.

Bu darsdan soâ€˜ng sizning qoâ€˜lingizda **mustaqil kod bloklarini yozish** qudrati paydo boâ€˜ldi â€” endi siz `package`â€™lar, `modules`, va **professional loyihani qanday strukturalash**ni oâ€˜rganishga tayyorsiz.

---